<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>co³.one</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #000;
      overflow-x: hidden;
      font-family: Georgia, 'Times New Roman', serif;
    }
    
    #container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }
    
    canvas {
      display: block;
    }
    
    /* Static upright text overlay */
    #logo-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scaleY(1.35) scale(1);
      font-family: Georgia, 'Times New Roman', serif;
      font-style: italic;
      font-size: 20vmin;
      color: #ff6700;
      text-shadow: 
        0.5px 0.5px 0 rgba(255, 255, 255, 0.45),
        1px 1px 0 rgba(255, 255, 255, 0.35),
        1.5px 1.5px 0 rgba(255, 255, 255, 0.15);
      user-select: none;
      z-index: 20;
      line-height: 1;
      letter-spacing: -0.02em;
      cursor: pointer;
      transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1), top 0.8s cubic-bezier(0.4, 0, 0.2, 1), filter 0.3s ease;
    }
    
    #logo-text:hover {
      filter: brightness(1.1);
    }
    
    #logo-text.shrunk {
      top: 15vh;
      transform: translate(-50%, 0) scaleY(1.35) scale(0.4);
    }
    
    #logo-text sup {
      font-size: 0.32em;
      vertical-align: super;
      margin-left: 0.15em;
      position: relative;
      top: -0.35em;
    }
    
    /* Back zone - invisible tap area */
    #back-zone {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 35vh;
      cursor: pointer;
      z-index: 100;
      pointer-events: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    #back-zone.visible {
      pointer-events: auto;
    }
    
    /* About section */
    #about {
      position: fixed;
      top: 100vh;
      left: 0;
      width: 100%;
      height: 100vh;
      overflow-y: auto;
      padding: 28vh 10vw 10vh;
      color: #fff;
      transition: top 0.8s ease;
      z-index: 5;
      background: transparent;
    }
    
    #about.visible {
      top: 0;
    }
    
    #about h2 {
      font-size: 2.5rem;
      font-style: italic;
      color: #ff6700;
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
      cursor: pointer;
      transition: filter 0.2s;
      position: relative;
      z-index: 15;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    #about h2:hover {
      filter: brightness(1.2);
    }
    
    #about p {
      font-size: 1.2rem;
      line-height: 1.8;
      max-width: 700px;
      margin-bottom: 1.5rem;
      color: #ccc;
      text-shadow: 0 1px 8px rgba(0,0,0,0.9);
    }
    
    #about a {
      color: #ff6700;
      text-decoration: none;
      border-bottom: 1px solid rgba(255, 103, 0, 0.3);
      transition: border-color 0.2s;
    }
    
    #about a:hover {
      border-color: #ff6700;
    }
    
    .links {
      margin-top: 3rem;
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
    }
    
    .links a {
      font-size: 1.1rem;
      padding: 0.8rem 1.5rem;
      border: 1px solid #ff6700;
      color: #ff6700;
      text-decoration: none;
      transition: background 0.2s, color 0.2s;
    }
    
    .links a:hover {
      background: #ff6700;
      color: #000;
    }
    
    /* Contact form */
    .contact-section {
      margin-top: 4rem;
      max-width: 500px;
      padding: 2rem;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 4px;
    }
    
    .contact-section h3 {
      font-size: 1.5rem;
      font-style: italic;
      color: #ff6700;
      margin-bottom: 1.5rem;
    }
    
    .form-group {
      margin-bottom: 1rem;
    }
    
    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 0.8rem 1rem;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #333;
      color: #fff;
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1rem;
      transition: border-color 0.2s;
    }
    
    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #ff6700;
    }
    
    .form-group input::placeholder,
    .form-group textarea::placeholder {
      color: #666;
    }
    
    .form-group textarea {
      resize: vertical;
      min-height: 100px;
    }
    
    #contact-form button {
      padding: 0.8rem 2rem;
      background: transparent;
      border: 1px solid #ff6700;
      color: #ff6700;
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    
    #contact-form button:hover {
      background: #ff6700;
      color: #000;
    }
    
  </style>
</head>
<body>
  <div id="container">
    <div id="logo-text">Co<sup>3</sup></div>
  </div>
  
  <div id="back-zone"></div>
  
  <div id="about">
    <h2>Coherence Consulting Company</h2>
    <p>
      Co³ ONE explores the mathematics of persistence—how systems maintain coherence 
      by optimizing distance from failure boundaries while preserving internal structure.
    </p>
    <p>
      The framework applies across domains: risk management, organizational design, 
      AI alignment, personal decision-making. The pattern is the same: sustainable 
      systems don't maximize gains, they maximize the probability of continued existence.
    </p>
    <p>
      This is the home of RCOT (Recursive Coherence Optimization Theory) and related work.
    </p>
    
    <div class="links">
      <a href="https://substack.com/@co3one" target="_blank">Substack</a>
      <a href="https://github.com/rickymp3" target="_blank">GitHub</a>
      <a href="https://www.instagram.com/co3.one" target="_blank">Instagram</a>
      <a href="https://www.youtube.com/@CO3ONE" target="_blank">YouTube</a>
    </div>
    
    <div class="contact-section">
      <h3>Contact</h3>
      <form id="contact-form" action="https://formsubmit.co/founder@co3.one" method="POST">
        <input type="hidden" name="_captcha" value="true">
        <input type="hidden" name="_subject" value="Co³ ONE Contact Form">
        <input type="hidden" name="_template" value="table">
        <div class="form-group">
          <input type="text" name="name" placeholder="Name" required>
        </div>
        <div class="form-group">
          <input type="email" name="email" placeholder="Email" required>
        </div>
        <div class="form-group">
          <textarea name="message" placeholder="Message" rows="4" required></textarea>
        </div>
        <button type="submit">Send</button>
      </form>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 0.01);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.insertBefore(renderer.domElement, container.firstChild);
    
    const gridColor = 0x4a4a4a;
    const accentColor = 0xff6700;
    
    const gridRadius = 5;
    const wellDepth = 3;
    const wellSharpness = 1.4;
    
    // Speed multiplier - goes crazy on transition
    let speedMultiplier = 1;
    let targetSpeed = 1;
    
    function calculateWellZ(r) {
      const normalizedR = r / gridRadius;
      const z = -wellDepth * Math.pow(1 - normalizedR, wellSharpness) / (normalizedR + 0.1);
      return Math.max(z, -wellDepth * 3.5);
    }
    
    // Flowing concentric rings
    const numRings = 28;
    const ringLifespans = [];
    const ringsGroup = new THREE.Group();
    
    for (let i = 0; i < numRings; i++) {
      ringLifespans.push({
        progress: i / numRings,
        baseSpeed: 0.12 + Math.random() * 0.04
      });
      
      const geometry = new THREE.BufferGeometry();
      const segments = 72;
      const positions = new Float32Array((segments + 1) * 3);
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const material = new THREE.LineBasicMaterial({ 
        color: gridColor,
        transparent: true,
        opacity: 0.7
      });
      
      const ring = new THREE.Line(geometry, material);
      ringsGroup.add(ring);
    }
    scene.add(ringsGroup);
    
    // Flowing radial spokes
    const numSpokes = 32;
    const particlesPerSpoke = 6;
    const spokeParticles = [];
    const spokesGroup = new THREE.Group();
    
    for (let i = 0; i < numSpokes; i++) {
      const angle = (i / numSpokes) * Math.PI * 2;
      
      for (let j = 0; j < particlesPerSpoke; j++) {
        spokeParticles.push({
          angle: angle,
          progress: j / particlesPerSpoke,
          baseSpeed: 0.1 + Math.random() * 0.06
        });
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(2 * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.LineBasicMaterial({
          color: gridColor,
          transparent: true,
          opacity: 0.5
        });
        
        const segment = new THREE.Line(geometry, material);
        spokesGroup.add(segment);
      }
    }
    scene.add(spokesGroup);
    
    // Static outer rim
    const rimGeometry = new THREE.RingGeometry(gridRadius - 0.05, gridRadius + 0.05, 72);
    const rimMaterial = new THREE.MeshBasicMaterial({ 
      color: gridColor, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    const rim = new THREE.Mesh(rimGeometry, rimMaterial);
    rim.rotation.x = -Math.PI / 2;
    rim.position.y = 0.01;
    scene.add(rim);
    
    let time = 0;
    
    function updateRings(delta) {
      ringsGroup.children.forEach((ring, i) => {
        const life = ringLifespans[i];
        
        life.progress += delta * life.baseSpeed * speedMultiplier;
        
        if (life.progress >= 1) {
          life.progress = 0;
          life.baseSpeed = 0.12 + Math.random() * 0.04;
        }
        
        const currentRadius = gridRadius * (1 - life.progress);
        
        const fadeStart = 0.65;
        if (life.progress > fadeStart) {
          ring.material.opacity = 0.7 * (1 - (life.progress - fadeStart) / (1 - fadeStart));
        } else {
          ring.material.opacity = 0.7;
        }
        
        const positions = ring.geometry.attributes.position.array;
        const segments = 72;
        
        for (let j = 0; j <= segments; j++) {
          const angle = (j / segments) * Math.PI * 2;
          const x = Math.cos(angle) * currentRadius;
          const z = Math.sin(angle) * currentRadius;
          const y = calculateWellZ(currentRadius);
          
          positions[j * 3] = x;
          positions[j * 3 + 1] = y;
          positions[j * 3 + 2] = z;
        }
        
        ring.geometry.attributes.position.needsUpdate = true;
      });
    }
    
    function updateSpokes(delta) {
      spokesGroup.children.forEach((segment, i) => {
        const particle = spokeParticles[i];
        
        particle.progress += delta * particle.baseSpeed * speedMultiplier;
        
        if (particle.progress >= 1) {
          particle.progress = 0;
          particle.baseSpeed = 0.1 + Math.random() * 0.06;
        }
        
        const segmentLength = 0.1;
        const startProgress = particle.progress;
        const endProgress = Math.min(particle.progress + segmentLength, 1);
        
        const startR = gridRadius * (1 - startProgress);
        const endR = gridRadius * (1 - endProgress);
        
        const fadeStart = 0.55;
        if (particle.progress > fadeStart) {
          segment.material.opacity = 0.5 * (1 - (particle.progress - fadeStart) / (1 - fadeStart));
        } else {
          segment.material.opacity = 0.5;
        }
        
        const positions = segment.geometry.attributes.position.array;
        
        positions[0] = Math.cos(particle.angle) * startR;
        positions[1] = calculateWellZ(startR);
        positions[2] = Math.sin(particle.angle) * startR;
        
        positions[3] = Math.cos(particle.angle) * endR;
        positions[4] = calculateWellZ(endR);
        positions[5] = Math.sin(particle.angle) * endR;
        
        segment.geometry.attributes.position.needsUpdate = true;
      });
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = 0.016;
      time += delta;
      
      // Smooth speed transitions
      speedMultiplier += (targetSpeed - speedMultiplier) * 0.05;
      
      updateRings(delta);
      updateSpokes(delta);
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // State
    let isExpanded = false;
    const logoText = document.getElementById('logo-text');
    const about = document.getElementById('about');
    const aboutTitle = document.querySelector('#about h2');
    const backZone = document.getElementById('back-zone');
    
    function goToSplash() {
      targetSpeed = 15;
      backZone.classList.remove('visible');
      
      setTimeout(() => {
        targetSpeed = 1;
        logoText.classList.remove('shrunk');
        about.classList.remove('visible');
        document.body.style.overflow = 'hidden';
        isExpanded = false;
      }, 400);
    }
    
    function goToAbout() {
      targetSpeed = 25;
      
      setTimeout(() => {
        targetSpeed = 0.5;
        logoText.classList.add('shrunk');
        about.classList.add('visible');
        backZone.classList.add('visible');
        document.body.style.overflow = 'auto';
        isExpanded = true;
      }, 600);
    }
    
    // Click logo to toggle
    logoText.addEventListener('click', () => {
      if (!isExpanded) {
        goToAbout();
      } else {
        goToSplash();
      }
    });
    
    // Click title to go back to splash
    aboutTitle.addEventListener('click', () => {
      if (isExpanded) {
        goToSplash();
      }
    });
    
    // Click back zone to go back to splash
    backZone.addEventListener('click', () => {
      if (isExpanded) {
        goToSplash();
      }
    });
  </script>
</body>
</html>
