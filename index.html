<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CoÂ³ Logo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #000;
      overflow: hidden;
    }
    
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    
    canvas {
      display: block;
    }
    
    /* Static upright text overlay */
    #logo-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scaleY(1.35);
      font-family: Georgia, 'Times New Roman', serif;
      font-style: italic;
      font-size: 20vmin;
      color: #ff6700;
      text-shadow: 
        0.5px 0.5px 0 rgba(255, 255, 255, 0.45),
        1px 1px 0 rgba(255, 255, 255, 0.35),
        1.5px 1.5px 0 rgba(255, 255, 255, 0.15);
      user-select: none;
      z-index: 10;
      line-height: 1;
      letter-spacing: -0.02em;
      cursor: pointer;
      transition: transform 0.3s ease, filter 0.3s ease;
    }
    
    #logo-text:hover {
      transform: translate(-50%, -50%) scaleY(1.35) scale(1.05);
      filter: brightness(1.1);
    }
    
    #logo-text sup {
      font-size: 0.32em;
      vertical-align: super;
      margin-left: 0.15em;
      position: relative;
      top: -0.35em;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="logo-text">Co<sup>3</sup></div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    // Straight-on camera for flat logo view
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 0.01); // Almost directly above
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.insertBefore(renderer.domElement, container.firstChild);
    
    const gridColor = 0x4a4a4a;
    const accentColor = 0xff6700;
    
    const gridRadius = 5;
    const wellDepth = 3;
    const wellSharpness = 1.4;
    
    function calculateWellZ(r) {
      const normalizedR = r / gridRadius;
      const z = -wellDepth * Math.pow(1 - normalizedR, wellSharpness) / (normalizedR + 0.1);
      return Math.max(z, -wellDepth * 3.5);
    }
    
    // Flowing concentric rings
    const numRings = 28;
    const ringLifespans = [];
    const ringsGroup = new THREE.Group();
    
    for (let i = 0; i < numRings; i++) {
      ringLifespans.push({
        progress: i / numRings,
        speed: 0.12 + Math.random() * 0.04
      });
      
      const geometry = new THREE.BufferGeometry();
      const segments = 72;
      const positions = new Float32Array((segments + 1) * 3);
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const material = new THREE.LineBasicMaterial({ 
        color: gridColor,
        transparent: true,
        opacity: 0.7
      });
      
      const ring = new THREE.Line(geometry, material);
      ringsGroup.add(ring);
    }
    scene.add(ringsGroup);
    
    // Flowing radial spokes
    const numSpokes = 32;
    const particlesPerSpoke = 6;
    const spokeParticles = [];
    const spokesGroup = new THREE.Group();
    
    for (let i = 0; i < numSpokes; i++) {
      const angle = (i / numSpokes) * Math.PI * 2;
      
      for (let j = 0; j < particlesPerSpoke; j++) {
        spokeParticles.push({
          angle: angle,
          progress: j / particlesPerSpoke,
          speed: 0.1 + Math.random() * 0.06
        });
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(2 * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.LineBasicMaterial({
          color: gridColor,
          transparent: true,
          opacity: 0.5
        });
        
        const segment = new THREE.Line(geometry, material);
        spokesGroup.add(segment);
      }
    }
    scene.add(spokesGroup);
    
    // Static outer rim
    const rimGeometry = new THREE.RingGeometry(gridRadius - 0.05, gridRadius + 0.05, 72);
    const rimMaterial = new THREE.MeshBasicMaterial({ 
      color: gridColor, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.9
    });
    const rim = new THREE.Mesh(rimGeometry, rimMaterial);
    rim.rotation.x = -Math.PI / 2;
    rim.position.y = 0.01;
    scene.add(rim);
    
    let time = 0;
    
    function updateRings(delta) {
      ringsGroup.children.forEach((ring, i) => {
        const life = ringLifespans[i];
        
        life.progress += delta * life.speed;
        
        if (life.progress >= 1) {
          life.progress = 0;
          life.speed = 0.12 + Math.random() * 0.04;
        }
        
        const currentRadius = gridRadius * (1 - life.progress);
        
        const fadeStart = 0.65;
        if (life.progress > fadeStart) {
          ring.material.opacity = 0.7 * (1 - (life.progress - fadeStart) / (1 - fadeStart));
        } else {
          ring.material.opacity = 0.7;
        }
        
        const positions = ring.geometry.attributes.position.array;
        const segments = 72;
        
        for (let j = 0; j <= segments; j++) {
          const angle = (j / segments) * Math.PI * 2;
          const x = Math.cos(angle) * currentRadius;
          const z = Math.sin(angle) * currentRadius;
          const y = calculateWellZ(currentRadius);
          
          positions[j * 3] = x;
          positions[j * 3 + 1] = y;
          positions[j * 3 + 2] = z;
        }
        
        ring.geometry.attributes.position.needsUpdate = true;
      });
    }
    
    function updateSpokes(delta) {
      spokesGroup.children.forEach((segment, i) => {
        const particle = spokeParticles[i];
        
        particle.progress += delta * particle.speed;
        
        if (particle.progress >= 1) {
          particle.progress = 0;
          particle.speed = 0.1 + Math.random() * 0.06;
        }
        
        const segmentLength = 0.1;
        const startProgress = particle.progress;
        const endProgress = Math.min(particle.progress + segmentLength, 1);
        
        const startR = gridRadius * (1 - startProgress);
        const endR = gridRadius * (1 - endProgress);
        
        const fadeStart = 0.55;
        if (particle.progress > fadeStart) {
          segment.material.opacity = 0.5 * (1 - (particle.progress - fadeStart) / (1 - fadeStart));
        } else {
          segment.material.opacity = 0.5;
        }
        
        const positions = segment.geometry.attributes.position.array;
        
        positions[0] = Math.cos(particle.angle) * startR;
        positions[1] = calculateWellZ(startR);
        positions[2] = Math.sin(particle.angle) * startR;
        
        positions[3] = Math.cos(particle.angle) * endR;
        positions[4] = calculateWellZ(endR);
        positions[5] = Math.sin(particle.angle) * endR;
        
        segment.geometry.attributes.position.needsUpdate = true;
      });
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = 0.016;
      time += delta;
      
      updateRings(delta);
      updateSpokes(delta);
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Click logo to go to Substack
    document.getElementById('logo-text').addEventListener('click', () => {
      document.body.style.transition = 'opacity 0.4s ease';
      document.body.style.opacity = '0';
      setTimeout(() => {
        window.location.href = 'https://substack.com/@rcoro';
      }, 400);
    });
  </script>
</body>
</html>
